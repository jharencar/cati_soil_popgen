---
title: "Random Forest"
author: "Julia Harenčár"
date: "6/27/2024"
format: 
  html:
    code-fold: true
    code-tools: true
    code-overflow: wrap
    toc: true
    number-sections: true
theme:
  light: minty
  dark: superhero
editor_options: 
  chunk_output_type: console
---

## Random Forest analysis

Load packages:

```{r}
library(randomForest)
library(tidyverse)
library(stringr)
library(vegan)

```

### Read in data and get pairwise distances:

```{r}
## soil data
soils <- read.csv("soils_r.csv", header = T)

# sort soil data by plant ID to correspond with genetic data
soils <- soils[order(soils$plantID), ]

# remove plant 9 and Ca:Mg ratio
soils <- soils %>% 
  filter(plantID != 9) %>% 
  dplyr::select(-Ca_Mg_Ratio)

# Modified from Joes Mantel test code:
# Produce matrix of differnces in the abundance of soil components (Ba, Co, Mg, 
# etc. )

# Initialize empty vector to store information from the loop
soil_compound <- c()

# The first six columns are not soil chemical data, so we start the loop with
# columm seven
all_dfs <- list()

for (i in 7:ncol(soils)){
  
  # isolate one soil component
  this_compound <- soils[,i]
  
  # Produce distance matrix for the soil component
  dist_matrix <- as.matrix(vegdist(this_compound,method="euclidean",na.rm = TRUE))
  
  # Convert to data frame and reshape to long format
  dist_df <- as.data.frame(as.table(dist_matrix))
  
  # Get the name of the current soil component
  compound_name <- colnames(soils)[i]
  
  # Rename columns for clarity and add a column to identify the soil component
  colnames(dist_df) <- c("ID1", "ID2", compound_name)
  
  # Append the data frame to the list
  all_dfs[[i - 6]] <- dist_df
}

# Combine all data frames into one by merging on "ID1" and "ID2"
combined_soil_df <- all_dfs[[1]]

for (i in 2:length(all_dfs)) {
  combined_soil_df <- left_join(combined_soil_df, all_dfs[[i]], by = c("ID1", "ID2"))
}

## genetic data
load("CATIgind.RData")

# remove plant 9
snp_dat <- as.data.frame(CATIgind$tab)

snp_dat <- snp_dat[rownames(snp_dat) != "SSMT009_1", ]

# Genetic distance calculation modified from Joe's code:

# calculate euclidian genetic distance. This approach is used to create the
# square difference matrix and is capable of removing NAs from the calculation
# of distance
g_eucl_dist <- as.matrix( vegdist(snp_dat, method="euclidean", diag = TRUE, upper = TRUE, na.rm = TRUE))

## Scale distance values between 0 and 1. Divide all values in matrix by max value
#g_eucl_dist <- as.matrix(g_eucl_dist/max(g_eucl_dist))

# Convert matrix to data frame and reshape to long format
g_dist_df <- as.data.frame(as.table(g_eucl_dist))

# Rename columns for clarity
colnames(g_dist_df) <- c("ID1.old", "ID2.old", "genetic_distance")

# extract simple IDs to match soil dataframe
g_dist_df <- g_dist_df %>%
  mutate(ID1 = sub("^0+", "", str_extract(ID1.old, "(?<=0)\\d+(?=_)"))) %>% 
  mutate(ID2 = sub("^0+", "", str_extract(ID2.old, "(?<=0)\\d+(?=_)"))) %>% 
  dplyr::select(-ID1.old,-ID2.old)

# combine dataframes
full_comb <- merge(g_dist_df, combined_soil_df)

# Filter out duplicate and self-comparisons
full_comb <- full_comb %>%
  filter(ID1 != ID2) %>%
   distinct()
```

Fit random forest model:

```{r}
set.seed(1) # make reproducible

# remove ID col for randomForest
full_comb_no.id <- full_comb %>% 
  dplyr::select(-ID1, -ID2)

# fit model

# Run random forest analysis
rf_model <- randomForest(genetic_distance ~ ., data = full_comb_no.id, mtry=12)
print(rf_model)

varImpPlot(rf_model) 

# Tune model - indicates mtry best at 12 as opposed to 8 or 18... no real difference in results. 
tuneRF(x=full_comb_no.id[,-1], #define predictor variables
               y=full_comb_no.id$genetic_distance, #define response variable
               ntreeTry=500,
               mtryStart=12, 
               stepFactor=1.5,
               improve=0.01,
               trace=FALSE #don't show real-time progress
               )
```

Old probably useless code to combining snp and soil data:

```{r}
# convert gind to dataframe
snp_data <- as.data.frame(CATIgind)

# name ID col
snp_data <- cbind(rownames(snp_data), data.frame(snp_data, row.names=NULL))
names(snp_data)[1] <- 'old.ID'

# extract simple IDs to match soil dataframe
snp_data <- snp_data %>%
  mutate(plantID = sub("^0+", "", str_extract(old.ID, "(?<=0)\\d+(?=_)"))) %>% 
  select(!old.ID)

# combine dataframes
comb <- merge(snp_data, soil, by = "plantID")
```

### Covariance matrices

#### Raw soil covariance

```{r}
# Correlation heatmap in ggplot world:
library(ggcorrplot)

# subset raw soils data to remove genetic data:
soils_only <- soils[,5:31]

soils_cor_ggplot <- cor(soils_only)
#cor_ggplot <- cor(subset_chems_corr_above0.5)

# all variables
ggcorrplot(soils_cor_ggplot,
           lab = TRUE,              # show correlation values
           lab_size = 4,            # size of the correlation labels
           tl.cex = 11,              # axis tick label size
           tl.srt = 90)             # rotate x-axis labels

# Correlation plot matrix with psych package
library(psych)
pairs.panels(soils_only, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             gap = 0,
             cex = 2.5    # increase correlation value label size
             )

# Correlation plot after narrowing to those with strong correlations with our main chems of inerest:
colnames(soils_only)[colnames(soils_only) == 'aluminum'] <- 'Aluminum'
subset_raw_soil <- soils_only %>% dplyr::select(Calcium,Magnesium,Nickel,Copper,Silicon,Potassium,Strontium,Boron,Aluminum,Arsenic)

# Correlation plot matrix with psych package
library(psych)
pairs.panels(subset_raw_soil, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             gap = 0
             )
```

\

#### Genetic and soil distances covariance

```{r}
# Correlation heatmap in ggplot world:
library(ggcorrplot)
cor_ggplot <- cor(full_comb_no.id)
#cor_ggplot <- cor(subset_chems_corr_above0.5)

# all variables
ggcorrplot(cor_ggplot,
           lab = TRUE,              # show correlation values
           lab_size = 4,            # size of the correlation labels
           tl.cex = 11,              # axis tick label size
           tl.srt = 90)             # rotate x-axis labels
# selected variables


# Correlation plot matrix with psych package
library(psych)
pairs.panels(full_comb_no.id, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             gap = 0,
             cex = 2.5    # increase correlation value label size
             )

# Narrow down to those with stronger correlations
subset_chems_corr_above0.5 <- full_comb_no.id %>% dplyr::select(genetic_distance,Calcium,Magnesium,Barium,Copper,Nickel,Silicon,Strontium,Zinc,Manganese,Potassium,Chromium,Cadmium,Cobalt,NH4.N,Arsenic,Selenium,Phosphorus,Sulfur,Boron,aluminum)

subset_corr_above0.5_covar_plot <- pairs.panels(subset_chems_corr_above0.5, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             gap = 0,
             cex = 2.5 
             )

# Narrow further to those important in analysis and any that are strongly correlated with them
subset_chems_sml <- full_comb_no.id %>% dplyr::select(genetic_distance,Calcium,Magnesium,Nickel,Copper,Silicon,Strontium,Potassium,Boron,aluminum)

subset_corr_above0.5_covar_plot <- pairs.panels(subset_chems_sml, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = TRUE,  # show density plots
             ellipses = TRUE, # show correlation ellipses
             gap = 0
            # cex.labels = 1.5 # this makes the labels too big relative to the number labels... and makes genetic_distance not fit... but seems too small otherwise so not sure how best to do it
             )

# cov(full_comb_no.id)
# 
# pairs(~salary+education+age, data = df, main = "Scatterplot Matrix")

```

\

\
